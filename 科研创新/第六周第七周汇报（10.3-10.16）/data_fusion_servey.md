<center><b>Data fusion servey阅读报告</b></center>

## 摘要：

核心：基于数据整合（data integration）的大背景下的异构信息系统的融合（data fusion）研究

数据融合的定义：数据融合是将代表同一现实世界对象的多条记录融合成一个单一的、一致的、干净的表述的过程

数据融合的挑战：不确定和冲突值

文章介绍了多种数据融合技术，并介绍了他们在不同领域的应用



## 第一节 Introduction：

目标：通过一个一致的界面访问所有这些信息源

效果：完整是因为没有对象被遗忘在结果中；简明是因为没有对象被代表两次，呈现给用户的数据没有冲突（后者比前者更难，因为同一个数据可能来源于多个数据源）

挑战：连接不同机器上的不同数据源&&语义异质性（同一信息的不同表达方式）

解决方式：检查不同来源中的等价模式元素（模式匹配schema matching）和检测不同来源中的等价对象描述（重复检测duplicate detection）----》产生单一的、一致的表示，但是目前缺乏一致性的检测

挑战：冲突值的解决

解决方式：经常被忽略，通常只解决缺失值的不确定性来避免数据冲突



本论文的贡献：

介绍信息整合的大背景下的数据融合过程。介绍并比较了现有的实现这种数据融合步骤的方法

这个过程在文献中也被称为数据合并（data merging）、数据整合（data consolidation）、实体解析（entity resolution）或寻找代表/幸存者（finding representations/ survivors）



论文结构：

第一节：介绍

第二节：简要介绍了信息整合和需要执行的不同任务

第三节：对数据融合的关系技术进行了介绍、描述和分类

第四节：对综合信息系统及其数据融合能力进行了详细概述和分类



## 第二节：Data Fusion

### 2.0数据融合概览

![](G:\DB_research\科研创新\第六周第七周汇报（10.3-10.16）\picOfSuervey\1.jpeg)

集成信息系统：集合多个数据源的信息（查询底层数据源，合并结果）

​		第一步：模式映射，确定用来描述信息的属性值，将源中存在的数据转换为共同的表示形式。

​		第二步：识别和对齐不同对象，找到同一事件的不一致表达

​		第三步：重复表述被融合成单一表述&&解决数据不一致的问题---is called 数据融合（本文聚焦的焦点）

本节内容结构：介绍了前两个步骤的常见解决方案-----》然后在数据融合领域进行了更详细的讨论-----》展示技术和系统之间的差异



### 2.1数据转换

弥合异质性并因此指定数据转换的方法有两种：模式整合（schema integration）和模式映射（schema mapping），可以离线执行

​			模式整合：整合一组已知的数据源的愿望驱动的，**模式集成考虑的是各个模式，并试图生成一个新的模式**，这个模式对于源模式来说是完整和正确的，是最小的，而且是可以理解的。

​			模式映射：**假定有一个给定的目标模式**；也就是说，它是由在一个给定的综合信息系统中**包括一组来源的需要**所驱动的

​					模式匹配技术（模式映射的补充技术），它半自动地寻找两个模式之间的对应关系

模式集成和模式映射这两种方法的目标是相同的：**转换源的数据，使其符合一个共同的全局的模式。**

在数据整合之后，所有某种类型的对象都被同质化地表示。



### 2.2冗余检测

别名：记录链接（record linkage）、对象识别（object identification）、参照物调和等（reference reconciliation）

本阶段的处理目标：**识别同一现实世界对象的多种表现形式：数据融合（第三步）的基本输入。**

一般而言的冗余检测流程：使用**相似度测量法**比较每一对对象，并应用一个阈值。如果一对物体的**相似度高于给定的阈值，则宣布为重复**，一般而言有效性和效率是亟需关注的两个方面

有效性的讨论：相似性度量的质量&&相似性阈值的影响。

​						相似性度量：利用相似性函数，特定领域的度量&&一般的度量（字符的编辑距离）

​						相似性阈值：精准度和召回率的平衡，需要针对领域和数据集调整阈值

效率问题的讨论：1、存储所有数据集不可能---解决方法：智能分区，仅在分区内比对--排序邻域法

​							2、列文斯坦距离&&编辑距离的算法时间复杂度--解决方法：计算相似度上界，只计算上界高于相似度上界的pairs

冗余检测的结果：为每一种表示分配一个对象的ID，拥有相同id的表示重复。数据融合就是将一个对象的多种表征融合为一个表征



### 2.3完整而简明的数据整合

完整性的提高：在系统中增加更多的数据源（更多的对象，更多的描述对象的属性）

简明性的提高：删除多余的数据，融合重复的条目和将共同的属性合并成一个

我们可以自定义关于完整性以及简明性的客观公式定义：

![image-20221006124646089](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006124646089.png)

**扩展完备性**（Extensional completeness）：一个数据集中唯一的对象表述的数量与现实世界中唯一对象的总体数量的关系，该数据集所涵盖的现实世界物体的百分比。**扩展完备性的提高是通过增加更多的独特对象来实现的**

公式：
$$
extensional \ completeness=\frac{|| unique  \ objects \ in \  data set ||}{ ||all  \ unique  \ objects  \ in  \ universe||}=\frac{a}{a+c}
$$
S&T的扩展完备性：3/4

整合后的完备性：4/4



**内在完整性**（Intensional completeness）：在一个数据集中的唯一属性的数量与可用的唯一属性的总数量的关系。**内在完整的提高可以通过整合那些可以提供新属性的关系（也就是数据库中的表）来提高**

S&T的内在完备性：3/4

整合后的内在完备性：4/4



**扩展简洁性**（extensional conciseness）：数据集中唯一对象的数量与数据集中对象表现的总体数量的关系
$$
extensional \ conciseness=\frac{|| unique  \ objects \ in \  data set ||}{ ||all  \ objects  \ in  \ dataset||}=\frac{a}{a+b}
$$
整合后的内在完备性：4/4（四个对象都是不同的）



**内在简洁性**（intensional conciseness）：是一个数据集的独特属性的数量与总体属性数量的关系

整合后的内在完备性：4/4（四个属性都是不同的）



**为了使这些衡量措施起到作用，全局中的对象和所考虑的数据集的定义需要是相同的。**

四种不同程度的数据整合：

![image-20221006130608972](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006130608972.png)

（1）如果没有模式映射信息和对象标识符的知识，集成系统能做的最好的事情就是产生一个如图4（a）所示的结果。虽然这个结果**有很高的完整性，但它并不简明**

（2）如果能够由模式映射提供关于共同属性的结果，我们就可以得到（b）这个形状是对两个源关系（具有相同名称的映射属性）进行**外联合操作**的结果。我们称这样的结果为**内在简明**（intensionally concise）。没有一个真实世界的**属性**被一个以上的**属性**所代表。

（3）如果我们能够知道依据哪个/哪几个属性可以区分不同的对象，那么我们就可以根据这些属性进行全外连接，我们称这样的结果为**扩展简洁**（extensionally concise）。没有一个现实世界的对象是由一个以上的元组表示的

（4）识别共同属性（使用模式映射）和共同对象（使用对象标识符）后的结果：每个对象只有一行代表，每个属性只有一列代表。这样的结果（从内涵和外延上看都是简洁的）是数据融合的最终目标

问题：处理两个来源重叠区域的这些数据冲突（id=3时属性B的取值）（由结果中的检查模式标记）是数据融合的一个组成部分，将在接下来的章节中考虑。



### 2.4冲突分类

不同的冲突可以分为三类：

（1）有模式上的冲突，例如，不同的属性名称或不同结构的数据源---在前面通过模式映射都方式解决

（2）身份冲突，因为数据源中识别现实世界对象的方式可能不同。---通过寻找全局ID进行解决

（3）数据冲突--对同一个对象同一属性的值描述不同----仍然没有解决

对数据冲突的分类：

（1）属性值的不确定性，由信息缺失引起

（2）冲突，由不同属性值引起

不确定性：是一个非空值和一个或多个空值之间的冲突，这些空值都被用来描述一个对象的相同属性；不确定性比冲突更容易处理；假设控制是未知值。

冲突：两个或多个不同的非空值之间的冲突，这些值都被用来描述同一对象的相同属性。



### 2.5数据融合的策略和答案

1、数据融合策略：利用不同的策略将来源不同的数据融合为一个一致表示。

![image-20221006144951780](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006144951780.png)

![image-20221006145014646](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006145014646.png)

上面的两个表阐释了不同得数据融合策略：

**忽略冲突**的策略并不决定如何处理冲突的数据，有时甚至不知道数据冲突。他把冲突解决的工作延迟到了用户身上。

**避免冲突**的策略承认一般情况下可能存在的冲突，但不检测和解决单一的现有冲突。

​				常用思想：更偏爱某一个数据源的数据；用确定值代替空值；只返回一致的元组

**冲突解决策略**在决定如何解决冲突之前确实考虑了所有的数据和元数据

​				常用思想：决定性策略（从所有可能值中选一个）；调和性策略：（所选的值可能不在候选值中，例如取平均值）

2、数据融合答案：

对综合信息系统的查询结果就是数据融合答案。

答案的分类：

**完整的答案**：包含了所有的对象（外延完整）和所有的属性（内涵完整），这些都是来源中出现的。完整的答案不一定简洁

**简洁的答案**  现实中的对象（扩展简洁性）和语义等价的属性（内在简洁性）都只被描述一次

**一致的答案**：包含了所有满足完整性约束的元组，一致性答案不一定是完整的。一个一致性答案对于包含的对象来讲都是扩展简洁的（完整性约束有对key的约束）

**完整的答案和一致的答案**：包含所有现实中对象及其描述属性（不重复）的一致答案；这也是数据融合的目标

### 2.6激励性的例子

![image-20221006151306531](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006151306531.png)

上图所显示的就是在本论文中使用的例子。

内容解读：

1、大学提供的在校学生的数据。

2、由于这些大学都位于同一个城市，因此有可能在多所大学学习。

3、有可能将几个学习领域结合起来。

4、有些领域在不止一所大学提供，所以在主题以及学生方面有一定的重叠。

5、我们在例子中假设模式已经匹配，并且语义上相等的属性在例子中具有相同的名称。

6、所有的学生都可以通过他们的名字进行全局唯一的识别（真实世界的标识符）

7、真实世界的标识符不应该与数据库的主键相混淆

8、在本例中没有假设数据库主键



## 第三节 数据融合的关系运算符和技术

### 3.0简介

**本节介绍了标准和高级关系运算符，并研究了它们在融合不同数据源的数据方面的能力。**

标准的运算符：联合（union）和连接（join）

连接的技术：将几个表的元组结合起来同时对一些列进行谓词评估

结合的技术：先建立一个共同模式，再加入来自于源表的不同元组

更高级的运算符：结合标准运算符，发明更高级的运算符

约束：只对两个表进行运算符的操作 



### 3.1操作符和技术的属性和特点（operators运算符）

**我们使用以下一个或多个特征来描述以下操作符和技术。**

1、数据保存（value preservation）

当为了提高扩展完整性而组合表（combine tables）时，不一定所有的源值都包括在结果中，比如说两个属性描述的同一个事情。（下图为结合表的例子，注意区分结合表和数据库查询时做表连接时的区别）

![image-20221006154241097](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006154241097.png)

然而，为了使运算符完全达到数据保存的目的，所有描述对象的所有属性的所有值都需要保留在结果中。

**我们表示一个不会丢失任何值或创建或产生重复值的运算符为可以达到数据保存的运算符**

一个值的唯一存在是不够的，我们允许重复的值（详见下面关于bag union的定义）

因此，bag union是保值算子的例子，set union和Cartesian product是不保值算子的例子。

参考网址：http://www.turingmachine.org/courses/2007/saved.csc370S07/lectures/04_rel-algebra2.pdf

Cartesian product：笛卡尔积---会产生大量重复值

![image-20221006155252672](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006155252672.png)

bag union：在包上的并集计算，只是将值拿出来，并不是产生重复值

![image-20221006161920732](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006161920732.png)

set union：set只能存储唯一的对象（一个对象只能出现一次，所以会丢失值）

价值保存不应该被误认为是可恢复性的属性（这里不太懂是什么意思），也就是说，我们可以反转操作，并从结果中推断出来源中的价值（对象的属性值可能会丢失，但所有在源中被描述的对象夜莺包括在结果中）

可恢复性的一些可能的参考网页：https://blog.csdn.net/u010486124/article/details/42426127 大部分都是事务之间的调度

在价值保存中不考虑扩展完整性



2、唯一性

运算符的唯一性保护属性：在数据源中包含唯一属性的那些值在结果中同样保持唯一属性。举例：对于属性的等值连接为真，但对union操作为假（这里的union可以理解为表的uinon或理解为对查询结果的union）

一个创建包含唯一属性的结果（不管源中是否有唯一属性）的操作被称为具有唯一性强化属性（uniqueness-enforcing property ）

一个操作符需要在持有现实世界标识符的属性上具有唯一性



3、对操作符两种属性的总结：

理想的数据融合操作者，创建完整和一致的答案，应该尽可能多地保留数值和对象，同时强制或保留唯一性并解决冲突。



### 3.2连接操作符（Join Approaches）

#### 3.2.0 连接方法的总结

连接方法可以增加内在完整性（增加属性值），但不能保证扩展完整性（除非使用完全外连接full outer join）。

连接在扩展简洁性方面做的很好，但他依赖于全局唯一标识符并且源内不重复



3.2.1标准连接（stander join）

（equi_join）

如果连接条件由列之间的相等条件组成

在一些属性上使用等价连接建立一个真实世界的标识符，但在真实场景中有可能不使用全局标识符进行连接

键连接是唯一性的，但不一定是保值/保对象的

(natrual join)

把所用属性名相同的列中所有属性值相同的行连接起来

自然连接具有唯一性，但不具有数据保存性质

（full out join）（left out join）（right out join）

对不满足条件的行的处理区分了内连接和外连接

详细的教程：[带你了解数据库中JOIN的用法 - Coder编程 - 博客园 (cnblogs.com)](https://www.cnblogs.com/coder-programming/p/10668123.html)

该操作符仅在其基于键连接的完整变体中是保值/对象的。但是它在所有的变体中都是唯一性保存的

没太懂的地方：存在一个基于键连接or左连接or又连接的实体，他们只包含来自（第一or第二个）关系的元组



3.2.2 Full Disjunction. 

外连接的缺陷：通过外连接将两个以上的表结合起来可能会产生不同的结果表，这取决于表的连接顺序。

完全分离运算符：两个或多个表的组合，其中所有匹配的元组被合并为一个单一的元组。

完全分离运算符是具有唯一性的，并且是保值/保对象的，就像完全外部连接一样。

googel讲义：https://www.slideshare.net/atul_shridhar/full-disjunction-56682

![](G:\DB_research\科研创新\第六周第七周汇报（10.3-10.16）\picOfSuervey\2.png)

![](G:\DB_research\科研创新\第六周第七周汇报（10.3-10.16）\picOfSuervey\3.png)



3.2.3 匹配连接（match join）和容忍冲突的查询

第一步：来自所有来源的相应属性值被单独投射出来，并通过联合进行组合

第二步：然后，现实世界的标识符被用来重新连接，从而形成一个单一的大表。

参考实现代码：

![](G:\DB_research\科研创新\第六周第七周汇报（10.3-10.16）\picOfSuervey\4.png)

第三步：在产生的大表的基础上进行选择，根据附带的冲突容忍查询模型，从这个表中选择图元。在选择元组时增加参数传递。这个参数要么是高置信度，要么是随机证据，要么是根本不可能，并决定哪些图元被保留在结果中。

​				如果它被设置为高置信度，选择谓词需要对每个真实世界标识符的所有图元都为真。

​				如果它被设置为可能-所有，则选择谓词需要对每个真实世界标识符的至少一个图元为真。

​				随机证据（Random-evidence）对每个真实世界标识符的一个随机元组验证该谓词。

冲突解决：冲突是通过应用解决函数来解决的，比如sum、max、min、any等等

他的查询结果可能包含具有属性值组合的图元，这些属性值组合作为一个整体没有出现在任何一个源中。



3.2.4 提高连接结果的简洁性

普通的连接结果不包含对于相同语义属性的合并，生成的表完整但不一定简洁，有可能是矛盾的。

思路：增加额外的操作将属性进行合并。

![](G:\DB_research\科研创新\第六周第七周汇报（10.3-10.16）\picOfSuervey\5.png)

实操：使用函数coalesce(v1, v2, ... ,vn)返回v1到vn中第一个不是空值的值vi；可以用来对输入表进行优先排序

使用coalesce将关键列合并为一列（关键列要么包含相同的值要么包含空值）

什么是关键列：

![image-20221011101942237](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221011101942237.png)

广义派生操作（GAD）：将full Disjunction的几列合并为一列 GAD可以是用户定义的函数，从相同的语义列中选择一个作为结果

3.3 UNION方法

3.3.0 简介

扩展完整性的自然想法（包含来自两个源的元组），但是简洁性很差



3.3.1 Union, Outer Union, and Minimum Union

**联合**(∪)运算符(有集合语义)结合了两个联合兼容关系的图元，并删除了完全重复的图元，即所有属性值都相同的图元。不确定性和矛盾很多，忽略了冲突，不保值但是保对象。

联合兼容：属性数量相同，属性数据类型匹配

**外联合**：将两个非联合兼容的表联合起来（填充空值）不保值、但是保对象，不保留唯一性，忽略冲突

**最小联合运算符**：删除子元组的外联合结果，只能进行很小一部分的简洁性改善，还是没有解决冲突

**一个元组t1包含另一个元组t2：**

​							（1）如果它们符合相同的模式；

​							（2）如果t2包含更多的null

​							（3）其他属性对应相等



3.3.2 合并，按优先顺序合并

总结：两个外层连接的联合

![](G:\DB_research\科研创新\第六周第七周汇报（10.3-10.16）\picOfSuervey\6.png)

优点：可以填补某一个元组在某一张表的空缺，也提供了优先选择权限（U1优先的生成一张表，U2优先的生成一张表，再将两张表UNION）

缺点：不幸的是，这对同一张表中的相应图元（姑且理解为key值相同的表）不起作用，并且也没有解决矛盾

3.3.3 提高联合结果的简洁性。

使用分组操作提高外延简洁性（内在简洁性在表连接处理语义相同的属性时就被处理了）

以这种方式提高简洁性需要一个或多个属性作为ID来识别相同的现实世界对象

只使用sql定义的聚合函数是远远不够的，需要用户使用用户自定义的sql支持的函数。在4.3.5会详细说明

![](G:\DB_research\科研创新\第六周第七周汇报（10.3-10.16）\picOfSuervey\7.png)



### 3.4其他技术

3.4.0 简介

以下技术既不是基于连接的，也不是基于联合的，许多技术包含了额外的信息，扩展了关系模型或现有的关系运算符，或结合运算符以融合数据。

3.4.1 考虑到所有可能性

第一种处理方式：在元组中增加一列明确表示不确定性（离散的之或者连续的值都可以）。所有的关系代数运算都应考虑额外增加的一列，并且把所有元组连同增加的一列返回给用户。

第二种处理方式：“信任你的朋友”，增加一列信息表明数据是从哪里得到的

第三种处理方式：部分自然外连接：允许一个属性中的多个值以及它们作为正确值的概率，扩展了全分离操作。所有的值以及它是正确的值的概率都被留下了

第四种处理方式：通过概率分布模型模拟不确定性，最终只有一个值反馈给用户。

summary：所有这些方法都实施了考虑所有可能性的策略，利用**额外的信息**让用户有意识地在所有可能性中进行选择，或提出最可能的价值。

3.4.2 只考虑一致的可能性

一个简单的想法：只从数据库中返回一致的信息。（冗余会造成数据不一致，比如说A的手机号同时存了两个值那就是不一致的）

![image-20221006151306531](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006151306531.png)

例如在SELECT \* FROM U2的一致答案：Bob, Charly, 和Frank的元组。不一致的数据通过修复成为一致数据，例如删除掉Alice或者Eve的其中一行。

在一个查询中所有可能的修复的集合是一个查询的一致答案。与之对应的是一个可能的答案，他只要出现在一个元组中即可。找寻一致性答案是十分复杂的，所以现有的策略通常都会为之做出妥协。

