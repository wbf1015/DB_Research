## On Aligning Tuples for Regression

### 题目分析：

从题目看是为了回归分析而设计的数据对齐

### 摘要部分：

背景：回归分析需要多组变量，不同的变量是独立收集的，不具有同时性。

问题：同一时间产生的数值肯呢公益不同的时间戳记录。这让对齐工作变得困难。

现有解决方案：（1）连接具有相同时间戳的变量来对齐元组（回归模型的训练非常有限）；（2）依赖于数值和时间戳的相似性，但不幸的是，在回归变量中很可能不存在这种相似性。

提出的方案：bridge tuple alignment and regression（连接元组对齐和回归模型？）；具体阐述：将不同的变量的数值在一个元组中进行对齐，且他们具有的特性包括：在很短的时间内被记录（时间约束）、与回归模型非常吻合（**模型约束，这里不太懂，是和谁的回归模型吻合呢？**）

贡献：（1）提出具有时间和模型约束的元组对齐问题 （2）证明该问题是NP完全的 （3）设计一种有效的近似算法 （4）设计有效的剪枝策略。

测试：测试结果优于现有方法。

### 第一节：介绍：

核心问题：如何将不具有相同时间戳的多变量数据 “合理” 的结合在一个元组中

现在的解决方案：第一种方法是利用动态时间扭曲（DTW）：根据相似的值或接近的时间戳来对齐变量，而不是相等的时间戳。第二种方法是：利用插值法，在每一个时间戳的位置插上缺失值。（interpolating missing values at each timestamp，可以考虑时间和跨变量的相关性）---**插值法不太懂**，插值法不考虑时间戳的变化而是插入新值，很容易出错。

例子：展示一个学习回归模型的例子，通过有功功率（Active Power）和强度（Intensity）来预测电压

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\1.png)

图中元素的解读：红点是原始观测值、虚线表示被合并为一行的数据、蓝色三角形是从回归模型中预测的值，空心的红点是插值插出来的值（因此不适用于对齐）

分析图a：基于数值和时间相似的DTW变化，Power和Intensity有一些相似，但他们与voltage不相似，在错误对齐的匹配上进行学习导致预测分析不准确。

分析图b：基于插值法进行分析，基于插值法不考虑时间戳的对齐，只是在每个时间戳上进行插值但不做观察。，很容易引入新的错误

本项研究的创新之处：将元组对齐和回归相联系起来（创新：可不可以通过已经有的完整的能对上的时间戳数据进行变量关系的学习呢？）在迭代学习的回归模型指导下将一行中不同变量的值对齐，对齐的元组与在前一次迭代中学习的回归模型的预测值要很好的融合。于是乎，DTW中考虑数值的相似性可以被解释为对具有相似数值的变量的特殊回归模型，从而被作者的方法所包含。

本研究的基本概括：在一个元组中对齐多个变量的值，这些变量需要：（1）在短时间内被记录（2）与迭代学习的回归模型相吻合。也就是时间约束和模型约束。并且，这个策略是迭代应用的，吻合度高的数据将提高学习效果，改进后的回归模型会指导下一次对齐。

本篇论文的贡献：

(1) 我们形式化了一个新的问题，模型约束下的相似性对齐（SAMC），这是第一个利用时间和模型约束来对齐图元的问题。我们分析了该问题的NP完备性（定理1）。

(2) 我们设计了一种高效的近似算法，在理论上保证了性能（命题2）。

(3) 我们提出了具有理论结果的创新策略和结构，以实现有效的剪枝，从而大大降低时间成本（命题3和7）

(4) 通过设计实验证明该算法的有效性。

### 第二节：元组对齐的问题

考虑m个变量，每个变量的模式为Ti（Ui，Vi）其中Ti代表一个变量，Ui代表时间戳，也就是记录的该变量值被观察到的时间，Vi就是在Ui观察到的对应的值。这样，可以根据一个模式R（U1，U2，...Um，V1，V2，...,Vm）来进行元组对齐。

在本模型中，并不要求采样是规律的，也就是支持不规律的时间间隔。通过对R上的（V1，V2，...,Vm）进行映射来获得训练数据（**这一句话也不太懂，什么叫对元素的映射**）。回归模型会根据对齐的元组进行训练。

最正确的想法：根据相等的时间戳进行对齐，但相等的时间戳非常有限，于是很自然的想法就是对齐相似的时间戳，也叫相似性对齐。相似性对齐可以极大程度丰富训练数据（**别忘记我们的核心就是训练一个回归模型**），但是有很多根据相似性对齐原理来对齐的元组和回归模型非常不一致，为了排除掉这些与模型不一致的数据，不妨就以模型作为约束。

为了获得更多的训练元组，我们希望R中包含的元组尽可能的多，在模型约束下获取最佳的相似性对齐是NP难的，对此作者给出了一个近似算法

#### 2.1相似性对齐与模型约束

在本节中首先提出时间约束（将时间的差异约束在一个阈值内）然后根据回归模型设置模型约束，然后再将二者结合。

定义1：时间相似性

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\2.png)

A、B是R中代表时间的属性列，其中他们相差的的最大值可以设置为时间的相似性

定义二：对一个对齐的元组而言满足时间相似性：

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\3.png)

也就是说这个元组中代表着时间的对应列的最大差值不大于我们所设定的阈值

定义三：模型相似性，就是我用已经训练好的回归模型代入一个元组的非时间的属性值，模型预测出来的结果与元组中对齐的结果的差的绝对值。

那么很明显，这个值越大说明我们对齐的元组越不靠谱，因为我们认为我们训练模型所用的数据是高可靠的。（**创新1：其实一个很大的问题就是我接下来的一个训练结果其实很依赖于我一开始选择的去训练这个回归模型的元组质量，也就是说在用什么样的初始元组去训练回归模型是很关键的**）

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\4.png)

定义四：一个元组满足模型约束

模型预测的值和元组实际对齐的值相差不大于实现设置好的阈值

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\5.png)

problems：给出对齐问题的描述：

给出变量集合、时间约束阈值和模型约束阈值，来获得一个对齐后的元组R满足：

（1）一个变量的值只能被对齐一次

（2）每一个元组满足时间约束和模型约束

（3）这样的元组数量越多越好

下面他就说对于我提出的创新1他是怎么做的：使用equality/similarity（平等或相似）排列来获取一些初步的元组R，这些元组被用来学习回归模型M并且指导后续的排列，与EM算法类似，对齐的实例和模型M在迭代中互相改进。关于上面提到的平等和相似的概念他会在附录A.2中进行说明，并且他表明这些一开始就被选出来的模型都是所提出的约束模型下的相似性对齐的特例。

（**创新2：粗略的看了一下EM算法，好像用到了后验概率什么乱七八糟的，在想可不可以也引入概率模型来帮助我们进行选择呢？**）

[EM算法详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/40991784)

#### 2.2 难度分析

当变量的数量>=3的时候，解决对齐问题将变得困难。

作者给出了这样的一个结论就是给定m的变量，时间约束θ以及模型约束φ还有我想要的符合要求的元组个数k，那么当m>=3时以下问题是NP完全完全：

对于m个变量、时间约束θ以及模型约束φ，能否在R中组合出至少k个符合要求的元组是NP完全的

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\6.png)

### 3.对齐算法

受 maximum k-dimensional matching problem的问题启发设计了一种近似算法。在3.1节中首先计算得到一个候选元组集合Rc，这些元组单拿出来都可以满足时间约束以及模型约束，但是他们的时间戳是可以重复的，也就是说，很有可能一个属性在一个时间所对应的值在多个元组中（不同的时间下）被使用了。在3.2节中采用了局部搜索算法来消除重复的时间戳。最后在3.3节中提出了有效的剪枝策略。

#### 3.1候选元组的选择

在选择候选元组的时候，作者的思路是选择所有的可能的符合要求的（时间和模型约束）的元组，通过滑动窗口的方式进行回溯选择所有符合时间约束的元组。最后对所有的符合要求的元组进行模型约束的选择。

我来说一句人话来描述这个算法的过程，就是我以每一个元素在每一个时间点的值作为时间片的下界，然后在其他属性中去查找满足这个时间片约束的元组，然后并入集合

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\7.png)

也就是说以每一个变量的每一个值为最小的时间基准进行选择，在并入最终的候选模式时要进行去重。它的算法复杂性毫无疑问其实是比较高的**（创新三：在思考有没有可能降低这种时间复杂性，其实这样做去重也需要浪费很多时间）**

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\8.png)

#### 3.2 对齐元组的筛选

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\9.png)

这个步骤的筛选过程具体可以描述如下：首先使用贪心算法，遍历第一小节得到的Rc中的元组，并建立一个新的元组集合Rsm，只要Rc中的元组不与Rsm中的元组发生时间戳重合，那么就把他加入Rsm。

随后，我们规定一个阈值ρ，并且将那些在Rc中但不在Rsm中的元组设置为Runc，我们在Runc查找大小不超过ρ的元组集合Rout，Rout中的元组需要两两不存在时间戳重叠的情况，而Rout中的元组没有被选入Rsm的原因就在于Rsm中存在某些元组对Rout有时间戳重叠，找出这些元组，如果这些元组的数量小于Rout中元组的数量，那么就将Rsm中的这些元组Rin替换出来，从而完成了对于Rsm中元组的扩张。

那么问题就来了：这个过程会不会永远持续下去：先说结论，答案是不会的，因为每一次替换必然意味着Rsm规模的增长，但Rsm不可能无限制的增长，因为Rsm中元组的数量不会大于元组数最少的那个变量中的元组数目，否则就一定会有一个元组被重复使用。所以说这个算法一定会停止。

我们假设Rsm的最大数量为τ，所以替换最多发生τ次（我的理解就是这个τ应该就是所有的元素中具有数据项最少的那个元素的元组数量），每次替换需要遍历2到ρ，时间复杂度不会超过ρ次，而从Runc中选择p个不重叠的元素的个数最多试验一个多项式次数，用那个上下括号表示，根据我们熟悉的上界的算法估计，可以把Runc的值扩大成Rc，检查Rout需要不超过ρ的线性时间，寻找Rin需要不超过τ的线性时间。

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\10.png)

很明显的一件事情就是这样的算法并不能算出最正确的答案，原因很简单，因为只有当我们遍历ρ的取值时才能够算出最优的解，但那个时候算法复杂度会很大，因为那将是一个指数次的复杂度，因为我们会从Runc中选择ρ个变量，也就是一个背包问题，我们要枚举所有的可能，这是不现实的，但是根据作者提出的这个近似算法，作者得到了这样一个结论：

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\11.png)

根据选择的m以及ρ的不同，近似比也是不同的，计算公式如上图所示，我用C++代码简单的跑了一下结果，结果如下图：因为这个算法的近似是一个向上的近似，也就是说我们计算得到的Rc包括的元组数量越多越好，所以理论上这个近似值应该是（0,1）的，但是这个公式得到的结果确是大于1的，我的理解是要对这个近似比取倒数，因为ρ越大结果应该更趋向于最优解，计算结果也表明了这样的趋势，当我们取ρ=2时，算法得到的结果会大于0.5倍的最优解

**一个有意思的现象是，当我们增加m时，虽然ρ的值在不断变大，但是ρ=2到ρ=10的变化基本维持在一个定值0.5**

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\12.png)

而且，当ρ=2时，作者根据实验发现，算法的时间复杂度会有如下规律：也就是说，在实验中当ρ=2时，算法降低为多项式级的时间复杂度。

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\13.png)

#### 3.3优化和剪枝

在3.3中，作者提出了两种优化策略来优化算法项，根据前面的分析，作者提出的算法的时间复杂度的消耗主要耗费在了求所有固定大小的子集上了，那是一个指数级时间复杂度的算法。所以在本小节中作者的思路也是对该部分的算法进行优化。

优化的思路有两个：

第一个思路：我们知道，所有的候选式在Rc中，通过贪心算法求得的在Rsm中，我们要遍历子集的是Runc，具体的情况是Runc会很大但是Rsm会很小，那么我们可不可以不遍历Runc的子集而是转去遍历Rsm的子集呢？

第二个思路：如果要遍历所有的Rsm的子集，那这个开销也是很大的，那么有没有一种剪枝策略可以让我们不遍历所有的Rsm的子集，而是在一开始就去掉一些子集呢？

3.3.1：优化思路1

在寻找子集的时候在Rsm中寻找而不是在Runc中寻找，当给定最大的子集阈值ρ的时候，我们定义size p=1,2，......ρ-1，以p为大小去Rsm中寻找集合Rin。当找到Rin时寻找Runc的子集Rout，满足下面三个条件：

（1）Rout中的个数大于等于p+1 这个很好理解，因为只有这样了替换才有意义

（2）任何两个Rout中的元组时间戳不重叠

（3）Rout最多与Rsm中的p个元组时间戳重叠，这些元组都由Rin给出

有了以上条件，再引入一个定理：这个定理的意思是如果Runc中的Rout可以和Rsm中的Rin替换，那么其必然满足如下性质：对于任意Rout中的元组，必然存在Rin中的元组与之冲突；同理，Rin中的每一个元组也必然存在Rout中的元组与之冲突

我的理解就是：如果能把在外面的换进来，那一定说明里面的这一群和外面这一群是有所谓的利益关系的，而比较明显的利益关系就是一个Rin中的元组限制了一个或多个Rout中的元组，重要的是多个，一定要有多个才有替换的意义。

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\14.png)

3.3.2 OAPath剪枝与扩展的时间约束

OAPATH就是重叠交替路径，长度为l重叠就提路径就是说：总共有l个顶点，然后每一个相邻的点都是时间戳重叠的，且相邻的点一个属于Rout，一个属于Rin，这样的一条路径就被称为OA-path（我不明白这个节点是按照什么排列的）

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\15.png)

定理4：给定一个l长的OAPath，从r1和rl中任何一个元素的时间戳大小的差异不会超过lθ：

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\16.png)

定理5：任何连接起Rin和Rout中元组的路径必然是OAPath

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\17.png)

定理6：假设现在Rin的大小为p，并且算法已经成功找到了每一个可能的可以替换的大小小于p的Rin，那么此时如果Rin可以被Rout替换，那么一定存在一条ra，rb的OA路径的长度小于等于2p-1

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\18.png)

定理7：给定Rin且Rin中元组的个数为p，并且可以被Rout所替换，ra和rb都是Rin中的元素，则ra和rb之间的时间戳差值不会超过（2p-1）θ

通过这样的一个定理，我们就可以不遍历所有子集，当遍历时如果任意两个元组的时间戳差值大于了（2p-1）θ我们就可以结束这次选择

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\19.png)

于是可以给出完整的处理代码：添加的要点就在于需要判断（2p-1）θ这个条件是否被满足了，且注意在遍历选择Rout时只有当其中的每一个元组与Rin中的一个或多个元组具有时间戳重复的情况才能被加入选择，而且还要注意Rout中的元组不能具有重复的时间戳。

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\21.png)

时间复杂性的休息：如果只引入3.3.1的优化，其时间复杂性的提升如下：第一个近似可以理解成Rc（Rc-1）...可以看做多个Rc相乘，但是因为ρ比较小所以ρ（ρ-1）...在分母可以被ρ相乘时消掉，同理第二个近似

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\20.png)

如果同时运用3.3.1和3.3.2的优化，可以变为：相对于在ρ=2的时候变成一个伪线性的时间复杂度

![](G:\DB_research\科研创新\第九周汇报（10.24-10.30）\pic\22.png)



