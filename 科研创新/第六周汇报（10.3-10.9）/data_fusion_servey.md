<center><b>Data fusion servey阅读报告</b></center>

## 摘要：

核心：基于数据整合（data integration）的大背景下的异构信息系统的融合（data fusion）研究

数据融合的定义：数据融合是将代表同一现实世界对象的多条记录融合成一个单一的、一致的、干净的表述的过程

数据融合的挑战：不确定和冲突值

文章介绍了多种数据融合技术，并介绍了他们在不同领域的应用



## 第一节 Introduction：

目标：通过一个一致的界面访问所有这些信息源

效果：完整是因为没有对象被遗忘在结果中；简明是因为没有对象被代表两次，呈现给用户的数据没有冲突（后者比前者更难，因为同一个数据可能来源于多个数据源）

挑战：连接不同机器上的不同数据源&&语义异质性（同一信息的不同表达方式）

解决方式：检查不同来源中的等价模式元素（模式匹配schema matching）和检测不同来源中的等价对象描述（重复检测duplicate detection）----》产生单一的、一致的表示，但是目前缺乏一致性的检测

挑战：冲突值的解决

解决方式：经常被忽略，通常只解决缺失值的不确定性来避免数据冲突



本论文的贡献：

介绍信息整合的大背景下的数据融合过程。介绍并比较了现有的实现这种数据融合步骤的方法

这个过程在文献中也被称为数据合并（data merging）、数据整合（data consolidation）、实体解析（entity resolution）或寻找代表/幸存者（finding representations/ survivors）



论文结构：

第一节：介绍

第二节：简要介绍了信息整合和需要执行的不同任务

第三节：对数据融合的关系技术进行了介绍、描述和分类

第四节：对综合信息系统及其数据融合能力进行了详细概述和分类



## 第二节：Data Fusion

### 2.0数据融合概览

![](G:\DB_research\科研创新\第六周汇报（10.3-10.9）\picOfSuervey\1.jpeg)

集成信息系统：集合多个数据源的信息（查询底层数据源，合并结果）

​		第一步：模式映射，确定用来描述信息的属性值，将源中存在的数据转换为共同的表示形式。

​		第二步：识别和对齐不同对象，找到同一事件的不一致表达

​		第三步：重复表述被融合成单一表述&&解决数据不一致的问题---is called 数据融合（本文聚焦的焦点）

本节内容结构：介绍了前两个步骤的常见解决方案-----》然后在数据融合领域进行了更详细的讨论-----》展示技术和系统之间的差异



### 2.1数据转换

弥合异质性并因此指定数据转换的方法有两种：模式整合（schema integration）和模式映射（schema mapping），可以离线执行

​			模式整合：整合一组已知的数据源的愿望驱动的，**模式集成考虑的是各个模式，并试图生成一个新的模式**，这个模式对于源模式来说是完整和正确的，是最小的，而且是可以理解的。

​			模式映射：**假定有一个给定的目标模式**；也就是说，它是由在一个给定的综合信息系统中**包括一组来源的需要**所驱动的

​					模式匹配技术（模式映射的补充技术），它半自动地寻找两个模式之间的对应关系

模式集成和模式映射这两种方法的目标是相同的：**转换源的数据，使其符合一个共同的全局的模式。**

在数据整合之后，所有某种类型的对象都被同质化地表示。



### 2.2冗余检测

别名：记录链接（record linkage）、对象识别（object identification）、参照物调和等（reference reconciliation）

本阶段的处理目标：**识别同一现实世界对象的多种表现形式：数据融合（第三步）的基本输入。**

一般而言的冗余检测流程：使用**相似度测量法**比较每一对对象，并应用一个阈值。如果一对物体的**相似度高于给定的阈值，则宣布为重复**，一般而言有效性和效率是亟需关注的两个方面

有效性的讨论：相似性度量的质量&&相似性阈值的影响。

​						相似性度量：利用相似性函数，特定领域的度量&&一般的度量（字符的编辑距离）

​						相似性阈值：精准度和召回率的平衡，需要针对领域和数据集调整阈值

效率问题的讨论：1、存储所有数据集不可能---解决方法：智能分区，仅在分区内比对--排序邻域法

​							2、列文斯坦距离&&编辑距离的算法时间复杂度--解决方法：计算相似度上界，只计算上界高于相似度上界的pairs

冗余检测的结果：为每一种表示分配一个对象的ID，拥有相同id的表示重复。数据融合就是将一个对象的多种表征融合为一个表征



### 2.3完整而简明的数据整合

完整性的提高：在系统中增加更多的数据源（更多的对象，更多的描述对象的属性）

简明性的提高：删除多余的数据，融合重复的条目和将共同的属性合并成一个

我们可以自定义关于完整性以及简明性的客观公式定义：

![image-20221006124646089](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006124646089.png)

**扩展完备性**（Extensional completeness）：一个数据集中唯一的对象表述的数量与现实世界中唯一对象的总体数量的关系，该数据集所涵盖的现实世界物体的百分比。**扩展完备性的提高是通过增加更多的独特对象来实现的**

公式：
$$
extensional \ completeness=\frac{|| unique  \ objects \ in \  data set ||}{ ||all  \ unique  \ objects  \ in  \ universe||}=\frac{a}{a+c}
$$
S&T的扩展完备性：3/4

整合后的完备性：4/4



**内在完整性**（Intensional completeness）：在一个数据集中的唯一属性的数量与可用的唯一属性的总数量的关系。**内在完整的提高可以通过整合那些可以提供新属性的关系（也就是数据库中的表）来提高**

S&T的内在完备性：3/4

整合后的内在完备性：4/4



**扩展简洁性**（extensional conciseness）：数据集中唯一对象的数量与数据集中对象表现的总体数量的关系
$$
extensional \ conciseness=\frac{|| unique  \ objects \ in \  data set ||}{ ||all  \ objects  \ in  \ dataset||}=\frac{a}{a+b}
$$
整合后的内在完备性：4/4（四个对象都是不同的）



**内在简洁性**（intensional conciseness）：是一个数据集的独特属性的数量与总体属性数量的关系

整合后的内在完备性：4/4（四个属性都是不同的）



**为了使这些衡量措施起到作用，全局中的对象和所考虑的数据集的定义需要是相同的。**

四种不同程度的数据整合：

![image-20221006130608972](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006130608972.png)

（1）如果没有模式映射信息和对象标识符的知识，集成系统能做的最好的事情就是产生一个如图4（a）所示的结果。虽然这个结果**有很高的完整性，但它并不简明**

（2）如果能够由模式映射提供关于共同属性的结果，我们就可以得到（b）这个形状是对两个源关系（具有相同名称的映射属性）进行**外联合操作**的结果。我们称这样的结果为**内在简明**（intensionally concise）。没有一个真实世界的**属性**被一个以上的**属性**所代表。

（3）如果我们能够知道依据哪个/哪几个属性可以区分不同的对象，那么我们就可以根据这些属性进行全外连接，我们称这样的结果为**扩展简洁**（extensionally concise）。没有一个现实世界的对象是由一个以上的元组表示的

（4）识别共同属性（使用模式映射）和共同对象（使用对象标识符）后的结果：每个对象只有一行代表，每个属性只有一列代表。这样的结果（从内涵和外延上看都是简洁的）是数据融合的最终目标

问题：处理两个来源重叠区域的这些数据冲突（id=3时属性B的取值）（由结果中的检查模式标记）是数据融合的一个组成部分，将在接下来的章节中考虑。



### 2.4冲突分类

不同的冲突可以分为三类：

（1）有模式上的冲突，例如，不同的属性名称或不同结构的数据源---在前面通过模式映射都方式解决

（2）身份冲突，因为数据源中识别现实世界对象的方式可能不同。---通过寻找全局ID进行解决

（3）数据冲突--对同一个对象同一属性的值描述不同----仍然没有解决

对数据冲突的分类：

（1）属性值的不确定性，由信息缺失引起

（2）冲突，由不同属性值引起

不确定性：是一个非空值和一个或多个空值之间的冲突，这些空值都被用来描述一个对象的相同属性；不确定性比冲突更容易处理；假设控制是未知值。

冲突：两个或多个不同的非空值之间的冲突，这些值都被用来描述同一对象的相同属性。



### 2.5数据融合的策略和答案

1、数据融合策略：利用不同的策略将来源不同的数据融合为一个一致表示。

![image-20221006144951780](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006144951780.png)

![image-20221006145014646](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006145014646.png)

上面的两个表阐释了不同得数据融合策略：

**忽略冲突**的策略并不决定如何处理冲突的数据，有时甚至不知道数据冲突。他把冲突解决的工作延迟到了用户身上。

**避免冲突**的策略承认一般情况下可能存在的冲突，但不检测和解决单一的现有冲突。

​				常用思想：更偏爱某一个数据源的数据；用确定值代替空值；只返回一致的元组

**冲突解决策略**在决定如何解决冲突之前确实考虑了所有的数据和元数据

​				常用思想：决定性策略（从所有可能值中选一个）；调和性策略：（所选的值可能不在候选值中，例如取平均值）

2、数据融合答案：

对综合信息系统的查询结果就是数据融合答案。

答案的分类：

**完整的答案**：包含了所有的对象（外延完整）和所有的属性（内涵完整），这些都是来源中出现的。完整的答案不一定简洁

**简洁的答案**  现实中的对象（扩展简洁性）和语义等价的属性（内在简洁性）都只被描述一次

**一致的答案**：包含了所有满足完整性约束的元组，一致性答案不一定是完整的。一个一致性答案对于包含的对象来讲都是扩展简洁的（完整性约束有对key的约束）

**完整的答案和一致的答案**：包含所有现实中对象及其描述属性（不重复）的一致答案；这也是数据融合的目标

### 2.6激励性的例子

![image-20221006151306531](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006151306531.png)

上图所显示的就是在本论文中使用的例子。

内容解读：

1、大学提供的在校学生的数据。

2、由于这些大学都位于同一个城市，因此有可能在多所大学学习。

3、有可能将几个学习领域结合起来。

4、有些领域在不止一所大学提供，所以在主题以及学生方面有一定的重叠。

5、我们在例子中假设模式已经匹配，并且语义上相等的属性在例子中具有相同的名称。

6、所有的学生都可以通过他们的名字进行全局唯一的识别（真实世界的标识符）

7、真实世界的标识符不应该与数据库的主键相混淆

8、在本例中没有假设数据库主键



## 第三节 数据融合的关系运算符和技术

### 3.0简介

**本节介绍了标准和高级关系运算符，并研究了它们在融合不同数据源的数据方面的能力。**

标准的运算符：联合（union）和连接（join）

连接的技术：将几个表的元组结合起来同时对一些列进行谓词评估

结合的技术：先建立一个共同模式，再加入来自于源表的不同元组

更高级的运算符：结合标准运算符，发明更高级的运算符

约束：只对两个表进行运算符的操作 



### 3.1操作符和技术的属性和特点（operators运算符）

**我们使用以下一个或多个特征来描述以下操作符和技术。**

1、数据保存（value preservation）

当为了提高扩展完整性而组合表（combine tables）时，不一定所有的源值都包括在结果中。（下图为结合表的例子，注意区分结合表和数据库查询时做表连接时的区别）

![image-20221006154241097](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006154241097.png)

然而，为了使运算符完全达到数据保存的目的，所有描述对象的所有属性的所有值都需要保留在结果中。

**我们表示一个不会丢失任何值或创建或产生重复值的运算符为可以达到数据保存的运算符**

一个值的唯一存在是不够的，我们允许重复的值（详见下面关于bag union的定义）

因此，bag union是保值算子的例子，set union和Cartesian product是不保值算子的例子。

参考网址：http://www.turingmachine.org/courses/2007/saved.csc370S07/lectures/04_rel-algebra2.pdf

Cartesian product：笛卡尔积---会产生大量重复值

![image-20221006155252672](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006155252672.png)

bag union：在包上的并集计算，只是将值拿出来，并不是产生重复值

![image-20221006161920732](C:\Users\魏伯繁\AppData\Roaming\Typora\typora-user-images\image-20221006161920732.png)

set union：set只能存储唯一的对象（一个对象只能出现一次，所以会丢失值）

价值保存不应该被误认为是可恢复性的属性（这里不太懂是什么意思），也就是说，我们可以反转操作，并从结果中推断出来源中的价值（对象的属性值可能会丢失，但所有在源中被描述的对象夜莺包括在结果中）

可恢复性的一些可能的参考网页：https://blog.csdn.net/u010486124/article/details/42426127 大部分都是事务之间的调度

在价值保存中不考虑扩展完整性
